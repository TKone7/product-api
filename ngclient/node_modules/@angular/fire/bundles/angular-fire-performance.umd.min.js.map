{"version":3,"sources":["ng://@angular/fire/performance/performance.ts","ng://@angular/fire/performance/performance.module.ts"],"names":["AUTOMATICALLY_TRACE_CORE_NG_METRICS","InjectionToken","INSTRUMENTATION_ENABLED","DATA_COLLECTION_ENABLED","AngularFirePerformance","app","automaticallyTraceCoreNgMetrics","instrumentationEnabled","dataCollectionEnabled","appRef","zone","platformId","_this","this","trace$","name","options","performance","pipe","switchMap","Observable","emitter","runOutsideAngular","trace","metrics","Object","keys","forEach","metric","putMetric","attributes","attribute","putAttribute","attributeSubscriptions","attribute$","map","subscribe","next","metricSubscriptions","metric$","incrementOnSubscriptions","incrementMetric$","incrementMetric","undefined","start","unsubscribe","stop","m","traceUntil","test","source$","subscriber","traceSubscription","tap","a","orComplete","traceWhile","traceUntilComplete","traceUntilFirst","of","isPlatformBrowser","import","empty","shareReplay","bufferSize","refCount","isStable","first","it","ɵlazySDKProxy","Injectable","args","providedIn","FirebaseApp","Optional","type","Inject","ApplicationRef","NgZone","decorators","PLATFORM_ID","AngularFirePerformanceModule","_","NgModule","providers"],"mappings":"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","sourcesContent":["import { Injectable, NgZone, ApplicationRef, InjectionToken, Inject, Optional, PLATFORM_ID } from '@angular/core';\nimport { Observable, Subscription, of, empty } from 'rxjs';\nimport { first, tap, map, shareReplay, switchMap } from 'rxjs/operators';\nimport { performance } from 'firebase/app';\nimport { FirebaseApp, ɵPromiseProxy, ɵlazySDKProxy } from '@angular/fire';\nimport { isPlatformBrowser } from '@angular/common';\n\n// SEMVER @ v6, drop and move core ng metrics to a service\nexport const AUTOMATICALLY_TRACE_CORE_NG_METRICS = new InjectionToken<boolean>('angularfire2.performance.auto_trace');\nexport const INSTRUMENTATION_ENABLED = new InjectionToken<boolean>('angularfire2.performance.instrumentationEnabled');\nexport const DATA_COLLECTION_ENABLED = new InjectionToken<boolean>('angularfire2.performance.dataCollectionEnabled');\n\nexport interface AngularFirePerformance extends Omit<ɵPromiseProxy<performance.Performance>, 'trace'> {};\n\nexport type TraceOptions = {\n  metrics?: {[key:string]: number},\n  attributes?: {[key:string]:string},\n  attribute$?: {[key:string]:Observable<string>},\n  incrementMetric$?: {[key:string]: Observable<number|void|null|undefined>},\n  metric$?: {[key:string]: Observable<number>}\n};\n\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFirePerformance {\n  \n  private readonly performance: Observable<performance.Performance>;\n\n  constructor(\n    app: FirebaseApp,\n    @Optional() @Inject(AUTOMATICALLY_TRACE_CORE_NG_METRICS) automaticallyTraceCoreNgMetrics:boolean|null,\n    @Optional() @Inject(INSTRUMENTATION_ENABLED) instrumentationEnabled:boolean|null,\n    @Optional() @Inject(DATA_COLLECTION_ENABLED) dataCollectionEnabled:boolean|null,\n    appRef: ApplicationRef,\n    private zone: NgZone,\n    @Inject(PLATFORM_ID) platformId:Object\n  ) {\n\n    this.performance = of(undefined).pipe(\n      switchMap(() => isPlatformBrowser(platformId) ? zone.runOutsideAngular(() => import('firebase/performance')) : empty()),\n      map(() => zone.runOutsideAngular(() => app.performance())),\n      tap(performance => {\n        if (instrumentationEnabled == false) { performance.instrumentationEnabled = false }\n        if (dataCollectionEnabled == false) { performance.dataCollectionEnabled = false }\n      }),\n      shareReplay({ bufferSize: 1, refCount: false }),\n    );\n\n    if (automaticallyTraceCoreNgMetrics != false) {\n\n      // TODO determine more built in metrics\n      // this leaks... move to a service?\n      appRef.isStable.pipe(\n        first(it => it),\n        this.traceUntilComplete('isStable')\n      ).subscribe();\n\n    }\n\n    return ɵlazySDKProxy(this, this.performance, zone);\n\n  }\n\n  private readonly trace$ = (name:string, options?: TraceOptions) =>\n    this.performance.pipe(\n      switchMap(performance =>\n        new Observable<void>(emitter =>\n          this.zone.runOutsideAngular(() => {\n            const trace = performance.trace(name);\n            options && options.metrics && Object.keys(options.metrics).forEach(metric => {\n              trace.putMetric(metric, options!.metrics![metric])\n            });\n            options && options.attributes && Object.keys(options.attributes).forEach(attribute => {\n              trace.putAttribute(attribute, options!.attributes![attribute])\n            });\n            const attributeSubscriptions = options && options.attribute$ ? Object.keys(options.attribute$).map(attribute =>\n              options!.attribute$![attribute].subscribe(next => trace.putAttribute(attribute, next))\n            ) : [];\n            const metricSubscriptions = options && options.metric$ ? Object.keys(options.metric$).map(metric =>\n              options!.metric$![metric].subscribe(next => trace.putMetric(metric, next))\n            ) : [];\n            const incrementOnSubscriptions = options && options.incrementMetric$ ? Object.keys(options.incrementMetric$).map(metric =>\n              options!.incrementMetric$![metric].subscribe(next => trace.incrementMetric(metric, next || undefined))\n            ) : [];\n            emitter.next(trace.start());\n            return { unsubscribe: () => {\n              trace.stop();\n              metricSubscriptions.forEach(m => m.unsubscribe());\n              incrementOnSubscriptions.forEach(m => m.unsubscribe());\n              attributeSubscriptions.forEach(m => m.unsubscribe());\n            }};\n          })\n        )\n      )\n    );\n\n  public readonly traceUntil = <T=any>(name:string, test: (a:T) => boolean, options?: TraceOptions & { orComplete?: boolean }) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n    const traceSubscription = this.trace$(name, options).subscribe();\n    return source$.pipe(\n      tap(\n        a  => test(a) && traceSubscription.unsubscribe(),\n        () => {},\n        () => options && options.orComplete && traceSubscription.unsubscribe()\n      )\n    ).subscribe(subscriber);\n  });\n\n  public readonly traceWhile = <T=any>(name:string, test: (a:T) => boolean, options?: TraceOptions & { orComplete?: boolean}) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n    let traceSubscription: Subscription|undefined;\n    return source$.pipe(\n      tap(\n        a  => {\n          if (test(a)) {\n            traceSubscription = traceSubscription || this.trace$(name, options).subscribe();\n          } else {\n            traceSubscription && traceSubscription.unsubscribe();\n            traceSubscription = undefined;\n          }\n        },\n        () => {},\n        () => options && options.orComplete && traceSubscription && traceSubscription.unsubscribe()\n      )\n    ).subscribe(subscriber);\n  });\n\n  public readonly traceUntilComplete = <T=any>(name:string, options?: TraceOptions) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n    const traceSubscription = this.trace$(name, options).subscribe();\n    return source$.pipe(\n      tap(\n        () => {},\n        () => {},\n        () => traceSubscription.unsubscribe()\n      )\n    ).subscribe(subscriber);\n  });\n\n  public readonly traceUntilFirst = <T=any>(name:string, options?: TraceOptions) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n    const traceSubscription = this.trace$(name, options).subscribe();\n    return source$.pipe(\n      tap(\n        () => traceSubscription.unsubscribe(),\n        () => {},\n        () => {}\n      )\n    ).subscribe(subscriber);\n  });\n\n  public readonly trace = <T=any>(name:string, options?: TraceOptions) => (source$: Observable<T>) => new Observable<T>(subscriber => {\n    const traceSubscription = this.trace$(name, options).subscribe();\n    return source$.pipe(\n      tap(\n        () => traceSubscription.unsubscribe(),\n        () => {},\n        () => traceSubscription.unsubscribe()\n      )\n    ).subscribe(subscriber);\n  });\n\n}\n","import { NgModule } from '@angular/core';\nimport { AngularFirePerformance } from './performance';\n\n@NgModule({\n  providers: [ AngularFirePerformance ]\n})\nexport class AngularFirePerformanceModule {\n  constructor(_: AngularFirePerformance) {\n    // DI inject AFP here for the automatic data collection\n  } \n}\n"]}