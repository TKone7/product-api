/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { InjectionToken, NgZone, PLATFORM_ID, Injectable, Inject, Optional } from '@angular/core';
import { of, from } from 'rxjs';
import { AngularFirestoreDocument } from './document/document';
import { AngularFirestoreCollection } from './collection/collection';
import { AngularFirestoreCollectionGroup } from './collection-group/collection-group';
import { FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵfirebaseAppFactory, ɵAngularFireSchedulers, ɵkeepUnstableUntilFirstFactory } from '@angular/fire';
import { isPlatformServer } from '@angular/common';
import * as i0 from "@angular/core";
import * as i1 from "@angular/fire";
/**
 * The value of this token determines whether or not the firestore will have persistance enabled
 * @type {?}
 */
export var ENABLE_PERSISTENCE = new InjectionToken('angularfire2.enableFirestorePersistence');
/** @type {?} */
export var PERSISTENCE_SETTINGS = new InjectionToken('angularfire2.firestore.persistenceSettings');
/** @type {?} */
export var SETTINGS = new InjectionToken('angularfire2.firestore.settings');
/**
 * A utility methods for associating a collection reference with
 * a query.
 *
 * @param {?} collectionRef - A collection reference to query
 * @param {?=} queryFn - The callback to create a query
 *
 * Example:
 * const { query, ref } = associateQuery(docRef.collection('items'), ref => {
 *  return ref.where('age', '<', 200);
 * });
 * @return {?}
 */
export function associateQuery(collectionRef, queryFn) {
    if (queryFn === void 0) { queryFn = (/**
     * @param {?} ref
     * @return {?}
     */
    function (ref) { return ref; }); }
    /** @type {?} */
    var query = queryFn(collectionRef);
    /** @type {?} */
    var ref = collectionRef;
    return { query: query, ref: ref };
}
/**
 * AngularFirestore Service
 *
 * This service is the main entry point for this feature module. It provides
 * an API for creating Collection and Reference services. These services can
 * then be used to do data updates and observable streams of the data.
 *
 * Example:
 *
 * import { Component } from '\@angular/core';
 * import { AngularFirestore, AngularFirestoreCollection, AngularFirestoreDocument } from '\@angular/fire/firestore';
 * import { Observable } from 'rxjs/Observable';
 * import { from } from 'rxjs/observable';
 *
 * \@Component({
 *   selector: 'app-my-component',
 *   template: `
 *    <h2>Items for {{ (profile | async)?.name }}
 *    <ul>
 *       <li *ngFor="let item of items | async">{{ item.name }}</li>
 *    </ul>
 *    <div class="control-input">
 *       <input type="text" #itemname />
 *       <button (click)="addItem(itemname.value)">Add Item</button>
 *    </div>
 *   `
 * })
 * export class MyComponent implements OnInit {
 *
 *   // services for data operations and data streaming
 *   private readonly itemsRef: AngularFirestoreCollection<Item>;
 *   private readonly profileRef: AngularFirestoreDocument<Profile>;
 *
 *   // observables for template
 *   items: Observable<Item[]>;
 *   profile: Observable<Profile>;
 *
 *   // inject main service
 *   constructor(private readonly afs: AngularFirestore) {}
 *
 *   ngOnInit() {
 *     this.itemsRef = afs.collection('items', ref => ref.where('user', '==', 'davideast').limit(10));
 *     this.items = this.itemsRef.valueChanges().map(snap => snap.docs.map(data => doc.data()));
 *     // this.items = from(this.itemsRef); // you can also do this with no mapping
 *
 *     this.profileRef = afs.doc('users/davideast');
 *     this.profile = this.profileRef.valueChanges();
 *   }
 *
 *   addItem(name: string) {
 *     const user = 'davideast';
 *     this.itemsRef.add({ name, user });
 *   }
 * }
 */
var AngularFirestore = /** @class */ (function () {
    /**
     * Each Feature of AngularFire has a FirebaseApp injected. This way we
     * don't rely on the main Firebase App instance and we can create named
     * apps and use multiple apps.
     * @param app
     */
    function AngularFirestore(options, nameOrConfig, shouldEnablePersistence, settings, platformId, zone, persistenceSettings) {
        var _this = this;
        this.schedulers = new ɵAngularFireSchedulers(zone);
        this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);
        this.firestore = zone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var app = ɵfirebaseAppFactory(options, zone, nameOrConfig);
            if (!app.firestore) {
                throw "You must import 'firebase/firestore' before using AngularFirestore";
            }
            /** @type {?} */
            var firestore = app.firestore();
            if (settings) {
                firestore.settings(settings);
            }
            return firestore;
        }));
        if (shouldEnablePersistence && !isPlatformServer(platformId)) {
            // We need to try/catch here because not all enablePersistence() failures are caught
            // https://github.com/firebase/firebase-js-sdk/issues/608
            /** @type {?} */
            var enablePersistence = (/**
             * @return {?}
             */
            function () {
                try {
                    return from(_this.firestore.enablePersistence(persistenceSettings || undefined).then((/**
                     * @return {?}
                     */
                    function () { return true; }), (/**
                     * @return {?}
                     */
                    function () { return false; })));
                }
                catch (e) {
                    return of(false);
                }
            });
            this.persistenceEnabled$ = zone.runOutsideAngular(enablePersistence);
        }
        else {
            this.persistenceEnabled$ = of(false);
        }
    }
    /**
     * @template T
     * @param {?} pathOrRef
     * @param {?=} queryFn
     * @return {?}
     */
    AngularFirestore.prototype.collection = /**
     * @template T
     * @param {?} pathOrRef
     * @param {?=} queryFn
     * @return {?}
     */
    function (pathOrRef, queryFn) {
        /** @type {?} */
        var collectionRef;
        if (typeof pathOrRef === 'string') {
            collectionRef = this.firestore.collection(pathOrRef);
        }
        else {
            collectionRef = pathOrRef;
        }
        var _a = associateQuery(collectionRef, queryFn), ref = _a.ref, query = _a.query;
        return new AngularFirestoreCollection(ref, query, this);
    };
    /**
     * Create a reference to a Firestore Collection Group based on a collectionId
     * and an optional query function to narrow the result
     * set.
     * @param collectionId
     * @param queryGroupFn
     */
    /**
     * Create a reference to a Firestore Collection Group based on a collectionId
     * and an optional query function to narrow the result
     * set.
     * @template T
     * @param {?} collectionId
     * @param {?=} queryGroupFn
     * @return {?}
     */
    AngularFirestore.prototype.collectionGroup = /**
     * Create a reference to a Firestore Collection Group based on a collectionId
     * and an optional query function to narrow the result
     * set.
     * @template T
     * @param {?} collectionId
     * @param {?=} queryGroupFn
     * @return {?}
     */
    function (collectionId, queryGroupFn) {
        /** @type {?} */
        var queryFn = queryGroupFn || ((/**
         * @param {?} ref
         * @return {?}
         */
        function (ref) { return ref; }));
        /** @type {?} */
        var collectionGroup = this.firestore.collectionGroup(collectionId);
        return new AngularFirestoreCollectionGroup(queryFn(collectionGroup), this);
    };
    /**
     * @template T
     * @param {?} pathOrRef
     * @return {?}
     */
    AngularFirestore.prototype.doc = /**
     * @template T
     * @param {?} pathOrRef
     * @return {?}
     */
    function (pathOrRef) {
        /** @type {?} */
        var ref;
        if (typeof pathOrRef === 'string') {
            ref = this.firestore.doc(pathOrRef);
        }
        else {
            ref = pathOrRef;
        }
        return new AngularFirestoreDocument(ref, this);
    };
    /**
     * Returns a generated Firestore Document Id.
     */
    /**
     * Returns a generated Firestore Document Id.
     * @return {?}
     */
    AngularFirestore.prototype.createId = /**
     * Returns a generated Firestore Document Id.
     * @return {?}
     */
    function () {
        return this.firestore.collection('_').doc().id;
    };
    AngularFirestore.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'any'
                },] }
    ];
    /** @nocollapse */
    AngularFirestore.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [FIREBASE_OPTIONS,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [FIREBASE_APP_NAME,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [ENABLE_PERSISTENCE,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SETTINGS,] }] },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] },
        { type: NgZone },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [PERSISTENCE_SETTINGS,] }] }
    ]; };
    /** @nocollapse */ AngularFirestore.ɵprov = i0.ɵɵdefineInjectable({ factory: function AngularFirestore_Factory() { return new AngularFirestore(i0.ɵɵinject(i1.FIREBASE_OPTIONS), i0.ɵɵinject(i1.FIREBASE_APP_NAME, 8), i0.ɵɵinject(ENABLE_PERSISTENCE, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(i0.PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(PERSISTENCE_SETTINGS, 8)); }, token: AngularFirestore, providedIn: "any" });
    return AngularFirestore;
}());
export { AngularFirestore };
if (false) {
    /** @type {?} */
    AngularFirestore.prototype.firestore;
    /** @type {?} */
    AngularFirestore.prototype.persistenceEnabled$;
    /** @type {?} */
    AngularFirestore.prototype.schedulers;
    /** @type {?} */
    AngularFirestore.prototype.keepUnstableUntilFirst;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZXN0b3JlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFuZ3VsYXIvZmlyZS9maXJlc3RvcmUvIiwic291cmNlcyI6WyJmaXJlc3RvcmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNsRyxPQUFPLEVBQWMsRUFBRSxFQUFFLElBQUksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUU1QyxPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvRCxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNyRSxPQUFPLEVBQUUsK0JBQStCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUN0RixPQUFPLEVBQXNDLGdCQUFnQixFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLHNCQUFzQixFQUFFLDhCQUE4QixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JMLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGlCQUFpQixDQUFDOzs7Ozs7O0FBTW5ELE1BQU0sS0FBTyxrQkFBa0IsR0FBRyxJQUFJLGNBQWMsQ0FBVSx5Q0FBeUMsQ0FBQzs7QUFDeEcsTUFBTSxLQUFPLG9CQUFvQixHQUFHLElBQUksY0FBYyxDQUFnQyw0Q0FBNEMsQ0FBQzs7QUFDbkksTUFBTSxLQUFPLFFBQVEsR0FBRyxJQUFJLGNBQWMsQ0FBVyxpQ0FBaUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUFjdkYsTUFBTSxVQUFVLGNBQWMsQ0FBQyxhQUFrQyxFQUFFLE9BQW9CO0lBQXBCLHdCQUFBLEVBQUE7Ozs7SUFBVSxVQUFBLEdBQUcsSUFBSSxPQUFBLEdBQUcsRUFBSCxDQUFHLENBQUE7O1FBQy9FLEtBQUssR0FBRyxPQUFPLENBQUMsYUFBYSxDQUFDOztRQUM5QixHQUFHLEdBQUcsYUFBYTtJ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SCxVQUFPLFNBQXFDOztZQUN0QyxHQUFzQjtRQUMxQixJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtZQUNqQyxHQUFHLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDckM7YUFBTTtZQUNMLEdBQUcsR0FBRyxTQUFTLENBQUM7U0FDakI7UUFDRCxPQUFPLElBQUksd0JBQXdCLENBQUksR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFRDs7T0FFRzs7Ozs7SUFDSCxtQ0FBUTs7OztJQUFSO1FBQ0UsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUE7SUFDaEQsQ0FBQzs7Z0JBNUdGLFVBQVUsU0FBQztvQkFDVixVQUFVLEVBQUUsS0FBSztpQkFDbEI7Ozs7Z0RBY0ksTUFBTSxTQUFDLGdCQUFnQjtnREFDdkIsUUFBUSxZQUFJLE1BQU0sU0FBQyxpQkFBaUI7Z0RBQ3BDLFFBQVEsWUFBSSxNQUFNLFNBQUMsa0JBQWtCO2dEQUNyQyxRQUFRLFlBQUksTUFBTSxTQUFDLFFBQVE7Z0JBQ0ssTUFBTSx1QkFBdEMsTUFBTSxTQUFDLFdBQVc7Z0JBOUdFLE1BQU07Z0RBZ0gxQixRQUFRLFlBQUksTUFBTSxTQUFDLG9CQUFvQjs7OzJCQWhINUM7Q0F1TUMsQUE3R0QsSUE2R0M7U0ExR1ksZ0JBQWdCOzs7SUFDM0IscUNBQStDOztJQUMvQywrQ0FBeUQ7O0lBQ3pELHNDQUFtRDs7SUFDbkQsa0RBQWlGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4sIE5nWm9uZSwgUExBVEZPUk1fSUQsIEluamVjdGFibGUsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mLCBmcm9tIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBTZXR0aW5ncywgUGVyc2lzdGVuY2VTZXR0aW5ncywgQ29sbGVjdGlvblJlZmVyZW5jZSwgRG9jdW1lbnRSZWZlcmVuY2UsIFF1ZXJ5Rm4sIFF1ZXJ5LCBRdWVyeUdyb3VwRm4sIEFzc29jaWF0ZWRSZWZlcmVuY2UgfSBmcm9tICcuL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgQW5ndWxhckZpcmVzdG9yZURvY3VtZW50IH0gZnJvbSAnLi9kb2N1bWVudC9kb2N1bWVudCc7XG5pbXBvcnQgeyBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbiB9IGZyb20gJy4vY29sbGVjdGlvbi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uR3JvdXAgfSBmcm9tICcuL2NvbGxlY3Rpb24tZ3JvdXAvY29sbGVjdGlvbi1ncm91cCc7XG5pbXBvcnQgeyBGaXJlYmFzZU9wdGlvbnMsIEZpcmViYXNlQXBwQ29uZmlnLCBGSVJFQkFTRV9PUFRJT05TLCBGSVJFQkFTRV9BUFBfTkFNRSwgybVmaXJlYmFzZUFwcEZhY3RvcnksIMm1QW5ndWxhckZpcmVTY2hlZHVsZXJzLCDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5IH0gZnJvbSAnQGFuZ3VsYXIvZmlyZSc7XG5pbXBvcnQgeyBpc1BsYXRmb3JtU2VydmVyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IGZpcmVzdG9yZSB9IGZyb20gJ2ZpcmViYXNlL2FwcCc7XG5cbi8qKlxuICogVGhlIHZhbHVlIG9mIHRoaXMgdG9rZW4gZGV0ZXJtaW5lcyB3aGV0aGVyIG9yIG5vdCB0aGUgZmlyZXN0b3JlIHdpbGwgaGF2ZSBwZXJzaXN0YW5jZSBlbmFibGVkXG4gKi9cbmV4cG9ydCBjb25zdCBFTkFCTEVfUEVSU0lTVEVOQ0UgPSBuZXcgSW5qZWN0aW9uVG9rZW48Ym9vbGVhbj4oJ2FuZ3VsYXJmaXJlMi5lbmFibGVGaXJlc3RvcmVQZXJzaXN0ZW5jZScpO1xuZXhwb3J0IGNvbnN0IFBFUlNJU1RFTkNFX1NFVFRJTkdTID0gbmV3IEluamVjdGlvblRva2VuPFBlcnNpc3RlbmNlU2V0dGluZ3N8dW5kZWZpbmVkPignYW5ndWxhcmZpcmUyLmZpcmVzdG9yZS5wZXJzaXN0ZW5jZVNldHRpbmdzJyk7XG5leHBvcnQgY29uc3QgU0VUVElOR1MgPSBuZXcgSW5qZWN0aW9uVG9rZW48U2V0dGluZ3M+KCdhbmd1bGFyZmlyZTIuZmlyZXN0b3JlLnNldHRpbmdzJyk7XG5cbi8qKlxuICogQSB1dGlsaXR5IG1ldGhvZHMgZm9yIGFzc29jaWF0aW5nIGEgY29sbGVjdGlvbiByZWZlcmVuY2Ugd2l0aFxuICogYSBxdWVyeS5cbiAqXG4gKiBAcGFyYW0gY29sbGVjdGlvblJlZiAtIEEgY29sbGVjdGlvbiByZWZlcmVuY2UgdG8gcXVlcnlcbiAqIEBwYXJhbSBxdWVyeUZuIC0gVGhlIGNhbGxiYWNrIHRvIGNyZWF0ZSBhIHF1ZXJ5XG4gKlxuICogRXhhbXBsZTpcbiAqIGNvbnN0IHsgcXVlcnksIHJlZiB9ID0gYXNzb2NpYXRlUXVlcnkoZG9jUmVmLmNvbGxlY3Rpb24oJ2l0ZW1zJyksIHJlZiA9PiB7XG4gKiAgcmV0dXJuIHJlZi53aGVyZSgnYWdlJywgJzwnLCAyMDApO1xuICogfSk7XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NvY2lhdGVRdWVyeShjb2xsZWN0aW9uUmVmOiBDb2xsZWN0aW9uUmVmZXJlbmNlLCBxdWVyeUZuID0gcmVmID0+IHJlZik6IEFzc29jaWF0ZWRSZWZlcmVuY2Uge1xuICBjb25zdCBxdWVyeSA9IHF1ZXJ5Rm4oY29sbGVjdGlvblJlZik7XG4gIGNvbnN0IHJlZiA9IGNvbGxlY3Rpb25SZWY7XG4gIHJldHVybiB7IHF1ZXJ5LCByZWYgfTtcbn1cblxuLyoqXG4gKiBBbmd1bGFyRmlyZXN0b3JlIFNlcnZpY2VcbiAqXG4gKiBUaGlzIHNlcnZpY2UgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHRoaXMgZmVhdHVyZSBtb2R1bGUuIEl0IHByb3ZpZGVzXG4gKiBhbiBBUEkgZm9yIGNyZWF0aW5nIENvbGxlY3Rpb24gYW5kIFJlZmVyZW5jZSBzZXJ2aWNlcy4gVGhlc2Ugc2VydmljZXMgY2FuXG4gKiB0aGVuIGJlIHVzZWQgdG8gZG8gZGF0YSB1cGRhdGVzIGFuZCBvYnNlcnZhYmxlIHN0cmVhbXMgb2YgdGhlIGRhdGEuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEFuZ3VsYXJGaXJlc3RvcmUsIEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uLCBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQgfSBmcm9tICdAYW5ndWxhci9maXJlL2ZpcmVzdG9yZSc7XG4gKiBpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcy9PYnNlcnZhYmxlJztcbiAqIGltcG9ydCB7IGZyb20gfSBmcm9tICdyeGpzL29ic2VydmFibGUnO1xuICpcbiAqIEBDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ2FwcC1teS1jb21wb25lbnQnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgPGgyPkl0ZW1zIGZvciB7eyAocHJvZmlsZSB8IGFzeW5jKT8ubmFtZSB9fVxuICogICAgPHVsPlxuICogICAgICAgPGxpICpuZ0Zvcj1cImxldCBpdGVtIG9mIGl0ZW1zIHwgYXN5bmNcIj57eyBpdGVtLm5hbWUgfX08L2xpPlxuICogICAgPC91bD5cbiAqICAgIDxkaXYgY2xhc3M9XCJjb250cm9sLWlucHV0XCI+XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiAjaXRlbW5hbWUgLz5cbiAqICAgICAgIDxidXR0b24gKGNsaWNrKT1cImFkZEl0ZW0oaXRlbW5hbWUudmFsdWUpXCI+QWRkIEl0ZW08L2J1dHRvbj5cbiAqICAgIDwvZGl2PlxuICogICBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIE15Q29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcbiAqXG4gKiAgIC8vIHNlcnZpY2VzIGZvciBkYXRhIG9wZXJhdGlvbnMgYW5kIGRhdGEgc3RyZWFtaW5nXG4gKiAgIHByaXZhdGUgcmVhZG9ubHkgaXRlbXNSZWY6IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPEl0ZW0+O1xuICogICBwcml2YXRlIHJlYWRvbmx5IHByb2ZpbGVSZWY6IEFuZ3VsYXJGaXJlc3RvcmVEb2N1bWVudDxQcm9maWxlPjtcbiAqXG4gKiAgIC8vIG9ic2VydmFibGVzIGZvciB0ZW1wbGF0ZVxuICogICBpdGVtczogT2JzZXJ2YWJsZTxJdGVtW10+O1xuICogICBwcm9maWxlOiBPYnNlcnZhYmxlPFByb2ZpbGU+O1xuICpcbiAqICAgLy8gaW5qZWN0IG1haW4gc2VydmljZVxuICogICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGFmczogQW5ndWxhckZpcmVzdG9yZSkge31cbiAqXG4gKiAgIG5nT25Jbml0KCkge1xuICogICAgIHRoaXMuaXRlbXNSZWYgPSBhZnMuY29sbGVjdGlvbignaXRlbXMnLCByZWYgPT4gcmVmLndoZXJlKCd1c2VyJywgJz09JywgJ2RhdmlkZWFzdCcpLmxpbWl0KDEwKSk7XG4gKiAgICAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXNSZWYudmFsdWVDaGFuZ2VzKCkubWFwKHNuYXAgPT4gc25hcC5kb2NzLm1hcChkYXRhID0+IGRvYy5kYXRhKCkpKTtcbiAqICAgICAvLyB0aGlzLml0ZW1zID0gZnJvbSh0aGlzLml0ZW1zUmVmKTsgLy8geW91IGNhbiBhbHNvIGRvIHRoaXMgd2l0aCBubyBtYXBwaW5nXG4gKlxuICogICAgIHRoaXMucHJvZmlsZVJlZiA9IGFmcy5kb2MoJ3VzZXJzL2RhdmlkZWFzdCcpO1xuICogICAgIHRoaXMucHJvZmlsZSA9IHRoaXMucHJvZmlsZVJlZi52YWx1ZUNoYW5nZXMoKTtcbiAqICAgfVxuICpcbiAqICAgYWRkSXRlbShuYW1lOiBzdHJpbmcpIHtcbiAqICAgICBjb25zdCB1c2VyID0gJ2RhdmlkZWFzdCc7XG4gKiAgICAgdGhpcy5pdGVtc1JlZi5hZGQoeyBuYW1lLCB1c2VyIH0pO1xuICogICB9XG4gKiB9XG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ2FueSdcbn0pXG5leHBvcnQgY2xhc3MgQW5ndWxhckZpcmVzdG9yZSB7XG4gIHB1YmxpYyByZWFkb25seSBmaXJlc3RvcmU6IGZpcmVzdG9yZS5GaXJlc3RvcmU7XG4gIHB1YmxpYyByZWFkb25seSBwZXJzaXN0ZW5jZUVuYWJsZWQkOiBPYnNlcnZhYmxlPGJvb2xlYW4+O1xuICBwdWJsaWMgcmVhZG9ubHkgc2NoZWR1bGVyczogybVBbmd1bGFyRmlyZVNjaGVkdWxlcnM7XG4gIHB1YmxpYyByZWFkb25seSBrZWVwVW5zdGFibGVVbnRpbEZpcnN0OiA8VD4ob2JzOiBPYnNlcnZhYmxlPFQ+KSA9PiBPYnNlcnZhYmxlPFQ+O1xuXG4gIC8qKlxuICAgKiBFYWNoIEZlYXR1cmUgb2YgQW5ndWxhckZpcmUgaGFzIGEgRmlyZWJhc2VBcHAgaW5qZWN0ZWQuIFRoaXMgd2F5IHdlXG4gICAqIGRvbid0IHJlbHkgb24gdGhlIG1haW4gRmlyZWJhc2UgQXBwIGluc3RhbmNlIGFuZCB3ZSBjYW4gY3JlYXRlIG5hbWVkXG4gICAqIGFwcHMgYW5kIHVzZSBtdWx0aXBsZSBhcHBzLlxuICAgKiBAcGFyYW0gYXBwXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBASW5qZWN0KEZJUkVCQVNFX09QVElPTlMpIG9wdGlvbnM6RmlyZWJhc2VPcHRpb25zLFxuICAgIEBPcHRpb25hbCgpIEBJbmplY3QoRklSRUJBU0VfQVBQX05BTUUpIG5hbWVPckNvbmZpZzpzdHJpbmd8RmlyZWJhc2VBcHBDb25maWd8bnVsbHx1bmRlZmluZWQsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChFTkFCTEVfUEVSU0lTVEVOQ0UpIHNob3VsZEVuYWJsZVBlcnNpc3RlbmNlOiBib29sZWFufG51bGwsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChTRVRUSU5HUykgc2V0dGluZ3M6IFNldHRpbmdzfG51bGwsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0LFxuICAgIHpvbmU6IE5nWm9uZSxcbiAgICBAT3B0aW9uYWwoKSBASW5qZWN0KFBFUlNJU1RFTkNFX1NFVFRJTkdTKSBwZXJzaXN0ZW5jZVNldHRpbmdzOiBQZXJzaXN0ZW5jZVNldHRpbmdzfG51bGwsXG4gICkge1xuICAgIHRoaXMuc2NoZWR1bGVycyA9IG5ldyDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyh6b25lKTtcbiAgICB0aGlzLmtlZXBVbnN0YWJsZVVudGlsRmlyc3QgPSDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KHRoaXMuc2NoZWR1bGVycywgcGxhdGZvcm1JZCk7XG5cbiAgICB0aGlzLmZpcmVzdG9yZSA9IHpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgY29uc3QgYXBwID0gybVmaXJlYmFzZUFwcEZhY3Rvcnkob3B0aW9ucywgem9uZSwgbmFtZU9yQ29uZmlnKTtcbiAgICAgIGlmICghYXBwLmZpcmVzdG9yZSkgeyB0aHJvdyBcIllvdSBtdXN0IGltcG9ydCAnZmlyZWJhc2UvZmlyZXN0b3JlJyBiZWZvcmUgdXNpbmcgQW5ndWxhckZpcmVzdG9yZVwiIH1cbiAgICAgIGNvbnN0IGZpcmVzdG9yZSA9IGFwcC5maXJlc3RvcmUoKTtcbiAgICAgIGlmIChzZXR0aW5ncykgeyBmaXJlc3RvcmUuc2V0dGluZ3Moc2V0dGluZ3MpIH1cbiAgICAgIHJldHVybiBmaXJlc3RvcmU7XG4gICAgfSk7XG5cbiAgICBpZiAoc2hvdWxkRW5hYmxlUGVyc2lzdGVuY2UgJiYgIWlzUGxhdGZvcm1TZXJ2ZXIocGxhdGZvcm1JZCkpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gdHJ5L2NhdGNoIGhlcmUgYmVjYXVzZSBub3QgYWxsIGVuYWJsZVBlcnNpc3RlbmNlKCkgZmFpbHVyZXMgYXJlIGNhdWdodFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZpcmViYXNlL2ZpcmViYXNlLWpzLXNkay9pc3N1ZXMvNjA4XG4gICAgICBjb25zdCBlbmFibGVQZXJzaXN0ZW5jZSA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmZpcmVzdG9yZS5lbmFibGVQZXJzaXN0ZW5jZShwZXJzaXN0ZW5jZVNldHRpbmdzIHx8IHVuZGVmaW5lZCkudGhlbigoKSA9PiB0cnVlLCAoKSA9PiBmYWxzZSkpO1xuICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICByZXR1cm4gb2YoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5wZXJzaXN0ZW5jZUVuYWJsZWQkID0gem9uZS5ydW5PdXRzaWRlQW5ndWxhcihlbmFibGVQZXJzaXN0ZW5jZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGVyc2lzdGVuY2VFbmFibGVkJCA9IG9mKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIGEgRmlyZXN0b3JlIENvbGxlY3Rpb24gYmFzZWQgb24gYSBwYXRoIG9yXG4gICAqIENvbGxlY3Rpb25SZWZlcmVuY2UgYW5kIGFuIG9wdGlvbmFsIHF1ZXJ5IGZ1bmN0aW9uIHRvIG5hcnJvdyB0aGUgcmVzdWx0XG4gICAqIHNldC5cbiAgICogQHBhcmFtIHBhdGhPclJlZlxuICAgKiBAcGFyYW0gcXVlcnlGblxuICAgKi9cbiAgY29sbGVjdGlvbjxUPihwYXRoOiBzdHJpbmcsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VD5cbiAgY29sbGVjdGlvbjxUPihyZWY6IENvbGxlY3Rpb25SZWZlcmVuY2UsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VD5cbiAgY29sbGVjdGlvbjxUPihwYXRoT3JSZWY6IHN0cmluZyB8IENvbGxlY3Rpb25SZWZlcmVuY2UsIHF1ZXJ5Rm4/OiBRdWVyeUZuKTogQW5ndWxhckZpcmVzdG9yZUNvbGxlY3Rpb248VD4ge1xuICAgIGxldCBjb2xsZWN0aW9uUmVmOiBDb2xsZWN0aW9uUmVmZXJlbmNlO1xuICAgIGlmICh0eXBlb2YgcGF0aE9yUmVmID09PSAnc3RyaW5nJykge1xuICAgICAgY29sbGVjdGlvblJlZiA9IHRoaXMuZmlyZXN0b3JlLmNvbGxlY3Rpb24ocGF0aE9yUmVmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29sbGVjdGlvblJlZiA9IHBhdGhPclJlZjtcbiAgICB9XG4gICAgY29uc3QgeyByZWYsIHF1ZXJ5IH0gPSBhc3NvY2lhdGVRdWVyeShjb2xsZWN0aW9uUmVmLCBxdWVyeUZuKTtcbiAgICByZXR1cm4gbmV3IEFuZ3VsYXJGaXJlc3RvcmVDb2xsZWN0aW9uPFQ+KHJlZiwgcXVlcnksIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhIEZpcmVzdG9yZSBDb2xsZWN0aW9uIEdyb3VwIGJhc2VkIG9uIGEgY29sbGVjdGlvbklkXG4gICAqIGFuZCBhbiBvcHRpb25hbCBxdWVyeSBmdW5jdGlvbiB0byBuYXJyb3cgdGhlIHJlc3VsdFxuICAgKiBzZXQuXG4gICAqIEBwYXJhbSBjb2xsZWN0aW9uSWRcbiAgICogQHBhcmFtIHF1ZXJ5R3JvdXBGblxuICAgKi9cbiAgY29sbGVjdGlvbkdyb3VwPFQ+KGNvbGxlY3Rpb25JZDogc3RyaW5nLCBxdWVyeUdyb3VwRm4/OiBRdWVyeUdyb3VwRm4pOiBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbkdyb3VwPFQ+IHtcbiAgICBjb25zdCBxdWVyeUZuID0gcXVlcnlHcm91cEZuIHx8IChyZWYgPT4gcmVmKTtcbiAgICBjb25zdCBjb2xsZWN0aW9uR3JvdXA6IFF1ZXJ5ID0gdGhpcy5maXJlc3RvcmUuY29sbGVjdGlvbkdyb3VwKGNvbGxlY3Rpb25JZCk7XG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlQ29sbGVjdGlvbkdyb3VwPFQ+KHF1ZXJ5Rm4oY29sbGVjdGlvbkdyb3VwKSwgdGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVmZXJlbmNlIHRvIGEgRmlyZXN0b3JlIERvY3VtZW50IGJhc2VkIG9uIGEgcGF0aCBvclxuICAgKiBEb2N1bWVudFJlZmVyZW5jZS4gTm90ZSB0aGF0IGRvY3VtZW50cyBhcmUgbm90IHF1ZXJ5YWJsZSBiZWNhdXNlIHRoZXkgYXJlXG4gICAqIHNpbXBseSBvYmplY3RzLiBIb3dldmVyLCBkb2N1bWVudHMgaGF2ZSBzdWItY29sbGVjdGlvbnMgdGhhdCByZXR1cm4gYVxuICAgKiBDb2xsZWN0aW9uIHJlZmVyZW5jZSBhbmQgY2FuIGJlIHF1ZXJpZWQuXG4gICAqIEBwYXJhbSBwYXRoT3JSZWZcbiAgICovXG4gIGRvYzxUPihwYXRoOiBzdHJpbmcpOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD5cbiAgZG9jPFQ+KHJlZjogRG9jdW1lbnRSZWZlcmVuY2UpOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD5cbiAgZG9jPFQ+KHBhdGhPclJlZjogc3RyaW5nIHwgRG9jdW1lbnRSZWZlcmVuY2UpOiBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD4ge1xuICAgIGxldCByZWY6IERvY3VtZW50UmVmZXJlbmNlO1xuICAgIGlmICh0eXBlb2YgcGF0aE9yUmVmID09PSAnc3RyaW5nJykge1xuICAgICAgcmVmID0gdGhpcy5maXJlc3RvcmUuZG9jKHBhdGhPclJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZiA9IHBhdGhPclJlZjtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBbmd1bGFyRmlyZXN0b3JlRG9jdW1lbnQ8VD4ocmVmLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZ2VuZXJhdGVkIEZpcmVzdG9yZSBEb2N1bWVudCBJZC5cbiAgICovXG4gIGNyZWF0ZUlkKCkge1xuICAgIHJldHVybiB0aGlzLmZpcmVzdG9yZS5jb2xsZWN0aW9uKCdfJykuZG9jKCkuaWRcbiAgfVxufVxuIl19