{"version":3,"file":"angular-fire-storage.js","sources":["ng://@angular/fire/storage/observable/fromTask.ts","ng://@angular/fire/storage/task.ts","ng://@angular/fire/storage/ref.ts","ng://@angular/fire/storage/storage.ts","ng://@angular/fire/storage/storage.module.ts"],"sourcesContent":["import { Observable } from 'rxjs';\nimport { UploadTask, UploadTaskSnapshot } from '../interfaces';\nimport { storage } from 'firebase/app';\n\nexport function fromTask(task: UploadTask) {\n  return new Observable<UploadTaskSnapshot>(subscriber => {\n    const progress = (snap: UploadTaskSnapshot) => subscriber.next(snap);\n    const error = e => subscriber.error(e);\n    const complete = () => subscriber.complete();\n    task.on('state_changed', progress, error, complete);\n    return () => task.cancel();\n  });\n}\n","import { UploadTaskSnapshot, UploadTask } from './interfaces';\nimport { fromTask } from './observable/fromTask';\nimport { Observable } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport interface AngularFireUploadTask {\n  task: UploadTask,\n  snapshotChanges(): Observable<UploadTaskSnapshot | undefined>;\n  percentageChanges(): Observable<number | undefined>;\n  pause(): boolean;\n  cancel(): boolean;\n  resume(): boolean;\n  then(\n    onFulfilled?: ((a: UploadTaskSnapshot) => any) | null, \n    onRejected?: ((a: Error) => any) | null\n  ): Promise<any>;\n  catch(onRejected: (a: Error) => any): Promise<any>;\n}\n\n/**\n * Create an AngularFireUploadTask from a regular UploadTask from the Storage SDK.\n * This method creates an observable of the upload and returns on object that provides\n * multiple methods for controlling and monitoring the file upload.\n * @param task \n */\nexport function createUploadTask(task: UploadTask): AngularFireUploadTask {\n  const inner$ = fromTask(task);\n  return {\n    task: task,\n    then: task.then.bind(task),\n    catch: task.catch.bind(task),\n    pause: task.pause.bind(task),\n    cancel: task.cancel.bind(task),\n    resume: task.resume.bind(task),\n    snapshotChanges: () => inner$,\n    percentageChanges: () => inner$.pipe(\n      map(s => s.bytesTransferred / s.totalBytes * 100)\n    )\n  };\n}\n","import { SettableMetadata, UploadMetadata, Reference, StringFormat } from './interfaces';\nimport { createUploadTask, AngularFireUploadTask } from './task';\nimport { Observable, from } from 'rxjs';\nimport { ɵAngularFireSchedulers } from '@angular/fire';\n\nexport interface AngularFireStorageReference {\n  getDownloadURL(): Observable<any>;\n  getMetadata(): Observable<any>;\n  delete(): Observable<any>;\n  child(path: string): any;\n  updateMetatdata(meta: SettableMetadata): Observable<any>;\n  updateMetadata(meta: SettableMetadata): Observable<any>;\n  put(data: any, metadata?: UploadMetadata | undefined): AngularFireUploadTask;\n  putString(data: string, format?: string | undefined, metadata?: UploadMetadata | undefined): AngularFireUploadTask;\n}\n\n/**\n * Create an AngularFire wrapped Storage Reference. This object\n * creates observable methods from promise based methods.\n * @param ref\n */\nexport function createStorageRef(\n  ref: Reference,\n  schedulers: ɵAngularFireSchedulers,\n  keepUnstableUntilFirst: <T>(obs$: Observable<T>) => Observable<T>\n): AngularFireStorageReference {\n  return {\n    getDownloadURL: () => from(ref.getDownloadURL(), schedulers.outsideAngular).pipe(\n      keepUnstableUntilFirst\n    ),\n    getMetadata: () => from(ref.getMetadata()).pipe(\n      keepUnstableUntilFirst\n    ),\n    delete: () => from(ref.delete()),\n    child: (path: string) => createStorageRef(ref.child(path), schedulers, keepUnstableUntilFirst),\n    updateMetatdata: (meta: SettableMetadata) => from(ref.updateMetadata(meta)),\n    updateMetadata: (meta: SettableMetadata) => from(ref.updateMetadata(meta)),\n    put: (data: any, metadata?: UploadMetadata) => {\n      const task = ref.put(data, metadata);\n      return createUploadTask(task);\n    },\n    putString: (data: string, format?: StringFormat, metadata?: UploadMetadata) => {\n      const task = ref.putString(data, format, metadata);\n      return createUploadTask(task);\n    }\n  };\n}\n","import { Injectable, Inject, Optional, InjectionToken, NgZone, PLATFORM_ID } from '@angular/core';\nimport { createStorageRef } from './ref';\nimport { Observable } from 'rxjs';\nimport { FirebaseOptions, FirebaseAppConfig, ɵfirebaseAppFactory, FIREBASE_OPTIONS, FIREBASE_APP_NAME, ɵkeepUnstableUntilFirstFactory, ɵAngularFireSchedulers } from '@angular/fire';\nimport { UploadMetadata } from './interfaces';\nimport { storage } from 'firebase/app';\n\nexport const BUCKET = new InjectionToken<string>('angularfire2.storageBucket');\n\n/**\n * AngularFireStorage Service\n *\n * This service is the main entry point for this feature module. It provides\n * an API for uploading and downloading binary files from Cloud Storage for\n * Firebase.\n */\n@Injectable({\n  providedIn: 'any'\n})\nexport class AngularFireStorage {\n  public readonly storage: storage.Storage;\n\n  public readonly keepUnstableUntilFirst: <T>(obs: Observable<T>) => Observable<T>;\n  public readonly schedulers: ɵAngularFireSchedulers;\n\n  constructor(\n    @Inject(FIREBASE_OPTIONS) options:FirebaseOptions,\n    @Optional() @Inject(FIREBASE_APP_NAME) nameOrConfig:string|FirebaseAppConfig|null|undefined,\n    @Optional() @Inject(BUCKET) storageBucket:string|null,\n    @Inject(PLATFORM_ID) platformId: Object,\n    zone: NgZone\n  ) {\n    this.schedulers = new ɵAngularFireSchedulers(zone);\n    this.keepUnstableUntilFirst = ɵkeepUnstableUntilFirstFactory(this.schedulers, platformId);\n\n    this.storage = zone.runOutsideAngular(() => {\n      const app = ɵfirebaseAppFactory(options, zone, nameOrConfig);\n      if (!app.storage) { throw \"You must import 'firebase/storage' before using AngularFireDatabase\" }\n      return app.storage(storageBucket || undefined);\n    });\n  }\n\n  ref(path: string) {\n    return createStorageRef(this.storage.ref(path), this.schedulers, this.keepUnstableUntilFirst);\n  }\n\n  upload(path: string, data: any, metadata?: UploadMetadata) {\n    const storageRef = this.storage.ref(path);\n    const ref = createStorageRef(storageRef, this.schedulers, this.keepUnstableUntilFirst);\n    return ref.put(data, metadata);\n  }\n\n}\n","import { NgModule } from '@angular/core';\nimport { AngularFireStorage } from './storage';\n\n@NgModule({\n  providers: [ AngularFireStorage ]\n})\nexport class AngularFireStorageModule { }\n"],"names":[],"mappings":";;;;;;;;;;;;;SAIgB,QAAQ,CAAC,IAAgB;IACvC,OAAO,IAAI,UAAU;;;;IAAqB,UAAU;;cAC5C,QAAQ;;;;QAAG,CAAC,IAAwB,KAAK,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAA;;cAC9D,KAAK;;;;QAAG,CAAC,IAAI,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAA;;cAChC,QAAQ;;;QAAG,MAAM,UAAU,CAAC,QAAQ,EAAE,CAAA;QAC5C,IAAI,CAAC,EAAE,CAAC,eAAe,EAAE,QAAQ,EAAE,KAAK,EAAE,QAAQ,CAAC,CAAC;QACpD;;;QAAO,MAAM,IAAI,CAAC,MAAM,EAAE,EAAC;KAC5B,EAAC,CAAC;AACL;;;;;;ACXA;;;AAIA,oCAYC;;;IAXC,qCAAiB;;;;IACjB,kEAA8D;;;;IAC9D,oEAAoD;;;;IACpD,wDAAiB;;;;IACjB,yDAAkB;;;;IAClB,yDAAkB;;;;;;IAClB,8EAGgB;;;;;IAChB,kEAAmD;;;;;;;;;AASrD,SAAgB,gBAAgB,CAAC,IAAgB;;UACzC,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC;IAC7B,OAAO;QACL,IAAI,EAAE,IAAI;QACV,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC;QAC1B,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;QAC5B,KAAK,EAAE,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC;QAC5B,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;QAC9B,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC;QAC9B,eAAe;;;QAAE,MAAM,MAAM,CAAA;QAC7B,iBAAiB;;;QAAE,MAAM,MAAM,CAAC,IAAI,CAClC,GAAG;;;;QAAC,CAAC,IAAI,CAAC,CAAC,gBAAgB,GAAG,CAAC,CAAC,UAAU,GAAG,GAAG,EAAC,CAClD,CAAA;KACF,CAAC;AACJ,CAAC;;;;;;ACtCD;;;AAIA,0CASC;;;;;IARC,uEAAkC;;;;IAClC,oEAA+B;;;;IAC/B,+DAA0B;;;;;IAC1B,kEAAyB;;;;;IACzB,4EAAyD;;;;;IACzD,2EAAwD;;;;;;IACxD,0EAA6E;;;;;;;IAC7E,wFAAmH;;;;;;;;;;AAQrH,SAAgB,gBAAgB,CAC9B,GAAc,EACd,UAAkC,EAClC,sBAAiE;IAEjE,OAAO;QACL,cAAc;;;QAAE,MAAM,IAAI,CAAC,GAAG,CAAC,cAAc,EAAE,EAAE,UAAU,CAAC,cAAc,CAAC,CAAC,IAAI,CAC9E,sBAAsB,CACvB,CAAA;QACD,WAAW;;;QAAE,MAAM,IAAI,CAAC,GAAG,CAAC,WAAW,EAAE,CAAC,CAAC,IAAI,CAC7C,sBAAsB,CACvB,CAAA;QACD,MAAM;;;QAAE,MAAM,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAA;QAChC,KAAK;;;;QAAE,CAAC,IAAY,KAAK,gBAAgB,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE,UAAU,EAAE,sBAAsB,CAAC,CAAA;QAC9F,eAAe;;;;QAAE,CAAC,IAAsB,KAAK,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAA;QAC3E,cAAc;;;;QAAE,CAAC,IAAsB,KAAK,IAAI,CAAC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC,CAAC,CAAA;QAC1E,GAAG;;;;;QAAE,CAAC,IAAS,EAAE,QAAyB;;kBAClC,IAAI,GAAG,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC;YACpC,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC;SAC/B,CAAA;QACD,SAAS;;;;;;QAAE,CAAC,IAAY,EAAE,MAAqB,EAAE,QAAyB;;kBAClE,IAAI,GAAG,GAAG,CAAC,SAAS,CAAC,IAAI,EAAE,MAAM,EAAE,QAAQ,CAAC;YAClD,OAAO,gBAAgB,CAAC,IAAI,CAAC,CAAC;SAC/B,CAAA;KACF,CAAC;AACJ,CAAC;;;;;;AC9CD;AAOA,MAAa,MAAM,GAAG,IAAI,cAAc,CAAS,4BAA4B,CAAC;;;;;;;;AAY9E,MAAa,kBAAkB;;;;;;;;IAM7B,YAC4B,OAAuB,EACV,YAAoD,EAC/D,aAAyB,EAChC,UAAkB,EACvC,IAAY;QAEZ,IAAI,CAAC,UAAU,GAAG,IAAI,sBAAsB,CAAC,IAAI,CAAC,CAAC;QACnD,IAAI,CAAC,sBAAsB,GAAG,8BAA8B,CAAC,IAAI,CAAC,UAAU,EAAE,UAAU,CAAC,CAAC;QAE1F,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,iBAAiB;;;QAAC;;kBAC9B,GAAG,GAAG,mBAAmB,CAAC,OAAO,EAAE,IAAI,EAAE,YAAY,CAAC;YAC5D,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE;gBAAE,MAAM,qEAAqE,CAAA;aAAE;YACjG,OAAO,GAAG,CAAC,OAAO,CAAC,aAAa,IAAI,SAAS,CAAC,CAAC;SAChD,EAAC,CAAC;KACJ;;;;;IAED,GAAG,CAAC,IAAY;QACd,OAAO,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,sBAAsB,CAAC,CAAC;KAC/F;;;;;;;IAED,MAAM,CAAC,IAAY,EAAE,IAAS,EAAE,QAAyB;;cACjD,UAAU,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC;;cACnC,GAAG,GAAG,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,sBAAsB,CAAC;QACtF,OAAO,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;KAChC;;;YAlCF,UAAU,SAAC;gBACV,UAAU,EAAE,KAAK;aAClB;;;;4CAQI,MAAM,SAAC,gBAAgB;4CACvB,QAAQ,YAAI,MAAM,SAAC,iBAAiB;4CACpC,QAAQ,YAAI,MAAM,SAAC,MAAM;YACO,MAAM,uBAAtC,MAAM,SAAC,WAAW;YA7BgC,MAAM;;;;;IAoB3D,qCAAyC;;IAEzC,oDAAiF;;IACjF,wCAAmD;;;;;;;ACvBrD,MAMa,wBAAwB;;;YAHpC,QAAQ,SAAC;gBACR,SAAS,EAAE,CAAE,kBAAkB,CAAE;aAClC;;;;;;;;;;;;;;;"}