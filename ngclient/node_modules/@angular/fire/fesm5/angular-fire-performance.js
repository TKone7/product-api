import { InjectionToken, Injectable, Optional, Inject, ApplicationRef, NgZone, PLATFORM_ID, ɵɵdefineInjectable, ɵɵinject, NgModule } from '@angular/core';
import { Observable, of, empty } from 'rxjs';
import { switchMap, tap, map, shareReplay, first } from 'rxjs/operators';
import { ɵlazySDKProxy, FirebaseApp } from '@angular/fire';
import { isPlatformBrowser } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// SEMVER @ v6, drop and move core ng metrics to a service
/** @type {?} */
var AUTOMATICALLY_TRACE_CORE_NG_METRICS = new InjectionToken('angularfire2.performance.auto_trace');
/** @type {?} */
var INSTRUMENTATION_ENABLED = new InjectionToken('angularfire2.performance.instrumentationEnabled');
/** @type {?} */
var DATA_COLLECTION_ENABLED = new InjectionToken('angularfire2.performance.dataCollectionEnabled');
// WARNING: interface has both a type and a value, skipping emit
;
var AngularFirePerformance = /** @class */ (function () {
    function AngularFirePerformance(app, automaticallyTraceCoreNgMetrics, instrumentationEnabled, dataCollectionEnabled, appRef, zone, platformId) {
        var _this = this;
        this.zone = zone;
        this.trace$ = (/**
         * @param {?} name
         * @param {?=} options
         * @return {?}
         */
        function (name, options) {
            return _this.performance.pipe(switchMap((/**
             * @param {?} performance
             * @return {?}
             */
            function (performance) {
                return new Observable((/**
                 * @param {?} emitter
                 * @return {?}
                 */
                function (emitter) {
                    return _this.zone.runOutsideAngular((/**
                     * @return {?}
                     */
                    function () {
                        /** @type {?} */
                        var trace = performance.trace(name);
                        options && options.metrics && Object.keys(options.metrics).forEach((/**
                         * @param {?} metric
                         * @return {?}
                         */
                        function (metric) {
                            trace.putMetric(metric, (/** @type {?} */ ((/** @type {?} */ (options)).metrics))[metric]);
                        }));
                        options && options.attributes && Object.keys(options.attributes).forEach((/**
                         * @param {?} attribute
                         * @return {?}
                         */
                        function (attribute) {
                            trace.putAttribute(attribute, (/** @type {?} */ ((/** @type {?} */ (options)).attributes))[attribute]);
                        }));
                        /** @type {?} */
                        var attributeSubscriptions = options && options.attribute$ ? Object.keys(options.attribute$).map((/**
                         * @param {?} attribute
                         * @return {?}
                         */
                        function (attribute) {
                            return (/** @type {?} */ ((/** @type {?} */ (options)).attribute$))[attribute].subscribe((/**
                             * @param {?} next
                             * @return {?}
                             */
                            function (next) { return trace.putAttribute(attribute, next); }));
                        })) : [];
                        /** @type {?} */
                        var metricSubscriptions = options && options.metric$ ? Object.keys(options.metric$).map((/**
                         * @param {?} metric
                         * @return {?}
                         */
                        function (metric) {
                            return (/** @type {?} */ ((/** @type {?} */ (options)).metric$))[metric].subscribe((/**
                             * @param {?} next
                             * @return {?}
                             */
                            function (next) { return trace.putMetric(metric, next); }));
                        })) : [];
                        /** @type {?} */
                        var incrementOnSubscriptions = options && options.incrementMetric$ ? Object.keys(options.incrementMetric$).map((/**
                         * @param {?} metric
                         * @return {?}
                         */
                        function (metric) {
                            return (/** @type {?} */ ((/** @type {?} */ (options)).incrementMetric$))[metric].subscribe((/**
                             * @param {?} next
                             * @return {?}
                             */
                            function (next) { return trace.incrementMetric(metric, next || undefined); }));
                        })) : [];
                        emitter.next(trace.start());
                        return { unsubscribe: (/**
                             * @return {?}
                             */
                            function () {
                                trace.stop();
                                metricSubscriptions.forEach((/**
                                 * @param {?} m
                                 * @return {?}
                                 */
                                function (m) { return m.unsubscribe(); }));
                                incrementOnSubscriptions.forEach((/**
                                 * @param {?} m
                                 * @return {?}
                                 */
                                function (m) { return m.unsubscribe(); }));
                                attributeSubscriptions.forEach((/**
                                 * @param {?} m
                                 * @return {?}
                                 */
                                function (m) { return m.unsubscribe(); }));
                            }) };
                    }));
                }));
            })));
        });
        this.traceUntil = (/**
         * @template T
         * @param {?} name
         * @param {?} test
         * @param {?=} options
         * @return {?}
         */
        function (name, test, options) { return (/**
         * @param {?} source$
         * @return {?}
         */
        function (source$) { return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            /** @type {?} */
            var traceSubscription = _this.trace$(name, options).subscribe();
            return source$.pipe(tap((/**
             * @param {?} a
             * @return {?}
             */
            function (a) { return test(a) && traceSubscription.unsubscribe(); }), (/**
             * @return {?}
             */
            function () { }), (/**
             * @return {?}
             */
            function () { return options && options.orComplete && traceSubscription.unsubscribe(); }))).subscribe(subscriber);
        })); }); });
        this.traceWhile = (/**
         * @template T
         * @param {?} name
         * @param {?} test
         * @param {?=} options
         * @return {?}
         */
        function (name, test, options) { return (/**
         * @param {?} source$
         * @return {?}
         */
        function (source$) { return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            /** @type {?} */
            var traceSubscription;
            return source$.pipe(tap((/**
             * @param {?} a
             * @return {?}
             */
            function (a) {
                if (test(a)) {
                    traceSubscription = traceSubscription || _this.trace$(name, options).subscribe();
                }
                else {
                    traceSubscription && traceSubscription.unsubscribe();
                    traceSubscription = undefined;
                }
            }), (/**
             * @return {?}
             */
            function () { }), (/**
             * @return {?}
             */
            function () { return options && options.orComplete && traceSubscription && traceSubscription.unsubscribe(); }))).subscribe(subscriber);
        })); }); });
        this.traceUntilComplete = (/**
         * @template T
         * @param {?} name
         * @param {?=} options
         * @return {?}
         */
        function (name, options) { return (/**
         * @param {?} source$
         * @return {?}
         */
        function (source$) { return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            /** @type {?} */
            var traceSubscription = _this.trace$(name, options).subscribe();
            return source$.pipe(tap((/**
             * @return {?}
             */
            function () { }), (/**
             * @return {?}
             */
            function () { }), (/**
             * @return {?}
             */
            function () { return traceSubscription.unsubscribe(); }))).subscribe(subscriber);
        })); }); });
        this.traceUntilFirst = (/**
         * @template T
         * @param {?} name
         * @param {?=} options
         * @return {?}
         */
        function (name, options) { return (/**
         * @param {?} source$
         * @return {?}
         */
        function (source$) { return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            /** @type {?} */
            var traceSubscription = _this.trace$(name, options).subscribe();
            return source$.pipe(tap((/**
             * @return {?}
             */
            function () { return traceSubscription.unsubscribe(); }), (/**
             * @return {?}
             */
            function () { }), (/**
             * @return {?}
             */
            function () { }))).subscribe(subscriber);
        })); }); });
        this.trace = (/**
         * @template T
         * @param {?} name
         * @param {?=} options
         * @return {?}
         */
        function (name, options) { return (/**
         * @param {?} source$
         * @return {?}
         */
        function (source$) { return new Observable((/**
         * @param {?} subscriber
         * @return {?}
         */
        function (subscriber) {
            /** @type {?} */
            var traceSubscription = _this.trace$(name, options).subscribe();
            return source$.pipe(tap((/**
             * @return {?}
             */
            function () { return traceSubscription.unsubscribe(); }), (/**
             * @return {?}
             */
            function () { }), (/**
             * @return {?}
             */
            function () { return traceSubscription.unsubscribe(); }))).subscribe(subscriber);
        })); }); });
        this.performance = of(undefined).pipe(switchMap((/**
         * @return {?}
         */
        function () { return isPlatformBrowser(platformId) ? zone.runOutsideAngular((/**
         * @return {?}
         */
        function () { return import('firebase/performance'); })) : empty(); })), map((/**
         * @return {?}
         */
        function () { return zone.runOutsideAngular((/**
         * @return {?}
         */
        function () { return app.performance(); })); })), tap((/**
         * @param {?} performance
         * @return {?}
         */
        function (performance) {
            if (instrumentationEnabled == false) {
                performance.instrumentationEnabled = false;
            }
            if (dataCollectionEnabled == false) {
                performance.dataCollectionEnabled = false;
            }
        })), shareReplay({ bufferSize: 1, refCount: false }));
        if (automaticallyTraceCoreNgMetrics != false) {
            // TODO determine more built in metrics
            // this leaks... move to a service?
            appRef.isStable.pipe(first((/**
             * @param {?} it
             * @return {?}
             */
            function (it) { return it; })), this.traceUntilComplete('isStable')).subscribe();
        }
        return ɵlazySDKProxy(this, this.performance, zone);
    }
    AngularFirePerformance.decorators = [
        { type: Injectable, args: [{
                    providedIn: 'any'
                },] }
    ];
    /** @nocollapse */
    AngularFirePerformance.ctorParameters = function () { return [
        { type: FirebaseApp },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [AUTOMATICALLY_TRACE_CORE_NG_METRICS,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INSTRUMENTATION_ENABLED,] }] },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DATA_COLLECTION_ENABLED,] }] },
        { type: ApplicationRef },
        { type: NgZone },
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    /** @nocollapse */ AngularFirePerformance.ɵprov = ɵɵdefineInjectable({ factory: function AngularFirePerformance_Factory() { return new AngularFirePerformance(ɵɵinject(FirebaseApp), ɵɵinject(AUTOMATICALLY_TRACE_CORE_NG_METRICS, 8), ɵɵinject(INSTRUMENTATION_ENABLED, 8), ɵɵinject(DATA_COLLECTION_ENABLED, 8), ɵɵinject(ApplicationRef), ɵɵinject(NgZone), ɵɵinject(PLATFORM_ID)); }, token: AngularFirePerformance, providedIn: "any" });
    return AngularFirePerformance;
}());
if (false) {
    /**
     * @type {?}
     * @private
     */
    AngularFirePerformance.prototype.performance;
    /**
     * @type {?}
     * @private
     */
    AngularFirePerformance.prototype.trace$;
    /** @type {?} */
    AngularFirePerformance.prototype.traceUntil;
    /** @type {?} */
    AngularFirePerformance.prototype.traceWhile;
    /** @type {?} */
    AngularFirePerformance.prototype.traceUntilComplete;
    /** @type {?} */
    AngularFirePerformance.prototype.traceUntilFirst;
    /** @type {?} */
    AngularFirePerformance.prototype.trace;
    /**
     * @type {?}
     * @private
     */
    AngularFirePerformance.prototype.zone;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var AngularFirePerformanceModule = /** @class */ (function () {
    function AngularFirePerformanceModule(_) {
        // DI inject AFP here for the automatic data collection
    }
    AngularFirePerformanceModule.decorators = [
        { type: NgModule, args: [{
                    providers: [AngularFirePerformance]
                },] }
    ];
    /** @nocollapse */
    AngularFirePerformanceModule.ctorParameters = function () { return [
        { type: AngularFirePerformance }
    ]; };
    return AngularFirePerformanceModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AUTOMATICALLY_TRACE_CORE_NG_METRICS, AngularFirePerformance, AngularFirePerformanceModule, DATA_COLLECTION_ENABLED, INSTRUMENTATION_ENABLED };
//# sourceMappingURL=angular-fire-performance.js.map
