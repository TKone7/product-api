import { NgZone, ApplicationRef, InjectionToken } from '@angular/core';
import { Observable } from 'rxjs';
import { performance } from 'firebase/app';
import { FirebaseApp, ɵPromiseProxy } from '@angular/fire';
export declare const AUTOMATICALLY_TRACE_CORE_NG_METRICS: InjectionToken<boolean>;
export declare const INSTRUMENTATION_ENABLED: InjectionToken<boolean>;
export declare const DATA_COLLECTION_ENABLED: InjectionToken<boolean>;
export interface AngularFirePerformance extends Omit<ɵPromiseProxy<performance.Performance>, 'trace'> {
}
export declare type TraceOptions = {
    metrics?: {
        [key: string]: number;
    };
    attributes?: {
        [key: string]: string;
    };
    attribute$?: {
        [key: string]: Observable<string>;
    };
    incrementMetric$?: {
        [key: string]: Observable<number | void | null | undefined>;
    };
    metric$?: {
        [key: string]: Observable<number>;
    };
};
export declare class AngularFirePerformance {
    private zone;
    private readonly performance;
    constructor(app: FirebaseApp, automaticallyTraceCoreNgMetrics: boolean | null, instrumentationEnabled: boolean | null, dataCollectionEnabled: boolean | null, appRef: ApplicationRef, zone: NgZone, platformId: Object);
    private readonly trace$;
    readonly traceUntil: <T = any>(name: string, test: (a: T) => boolean, options?: TraceOptions & {
        orComplete?: boolean;
    }) => (source$: Observable<T>) => Observable<T>;
    readonly traceWhile: <T = any>(name: string, test: (a: T) => boolean, options?: TraceOptions & {
        orComplete?: boolean;
    }) => (source$: Observable<T>) => Observable<T>;
    readonly traceUntilComplete: <T = any>(name: string, options?: TraceOptions) => (source$: Observable<T>) => Observable<T>;
    readonly traceUntilFirst: <T = any>(name: string, options?: TraceOptions) => (source$: Observable<T>) => Observable<T>;
    readonly trace: <T = any>(name: string, options?: TraceOptions) => (source$: Observable<T>) => Observable<T>;
}
