/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { isPlatformServer } from '@angular/common';
import { queueScheduler, asyncScheduler } from 'rxjs';
import { subscribeOn, observeOn, tap } from 'rxjs/operators';
/**
 * @return {?}
 */
function noop() { }
/**
 * Schedules tasks so that they are invoked inside the Zone that is passed in the constructor.
 */
export class ɵZoneScheduler {
    /**
     * @param {?} zone
     * @param {?=} delegate
     */
    constructor(zone, delegate = queueScheduler) {
        this.zone = zone;
        this.delegate = delegate;
    }
    /**
     * @return {?}
     */
    now() {
        return this.delegate.now();
    }
    /**
     * @param {?} work
     * @param {?=} delay
     * @param {?=} state
     * @return {?}
     */
    schedule(work, delay, state) {
        /** @type {?} */
        const targetZone = this.zone;
        // Wrap the specified work function to make sure that if nested scheduling takes place the
        // work is executed in the correct zone
        /** @type {?} */
        const workInZone = (/**
         * @this {?}
         * @param {?} state
         * @return {?}
         */
        function (state) {
            targetZone.runGuarded((/**
             * @return {?}
             */
            () => {
                work.apply(this, [state]);
            }));
        })
        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done
        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that
        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.
        ;
        // Scheduling itself needs to be run in zone to ensure setInterval calls for async scheduling are done
        // inside the correct zone. This scheduler needs to schedule asynchronously always to ensure that
        // firebase emissions are never synchronous. Specifying a delay causes issues with the queueScheduler delegate.
        return this.delegate.schedule(workInZone, delay, state);
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.zone;
    /**
     * @type {?}
     * @private
     */
    ɵZoneScheduler.prototype.delegate;
}
/**
 * @template T
 */
export class ɵBlockUntilFirstOperator {
    /**
     * @param {?} zone
     */
    constructor(zone) {
        this.zone = zone;
        this.task = null;
    }
    /**
     * @param {?} subscriber
     * @param {?} source
     * @return {?}
     */
    call(subscriber, source) {
        /** @type {?} */
        const unscheduleTask = this.unscheduleTask.bind(this);
        this.task = this.zone.run((/**
         * @return {?}
         */
        () => Zone.current.scheduleMacroTask('firebaseZoneBlock', noop, {}, noop, noop)));
        return source.pipe(tap(unscheduleTask, unscheduleTask, unscheduleTask)).subscribe(subscriber).add(unscheduleTask);
    }
    /**
     * @private
     * @return {?}
     */
    unscheduleTask() {
        if (this.task != null && this.task.state === 'scheduled') {
            this.task.invoke();
            this.task = null;
        }
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.task;
    /**
     * @type {?}
     * @private
     */
    ɵBlockUntilFirstOperator.prototype.zone;
}
export class ɵAngularFireSchedulers {
    /**
     * @param {?} ngZone
     */
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.outsideAngular = ngZone.runOutsideAngular((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current)));
        this.insideAngular = ngZone.run((/**
         * @return {?}
         */
        () => new ɵZoneScheduler(Zone.current, asyncScheduler)));
    }
}
if (false) {
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.outsideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.insideAngular;
    /** @type {?} */
    ɵAngularFireSchedulers.prototype.ngZone;
}
/**
 * Operator to block the zone until the first value has been emitted or the observable
 * has completed/errored. This is used to make sure that universal waits until the first
 * value from firebase but doesn't block the zone forever since the firebase subscription
 * is still alive.
 * @param {?} schedulers
 * @param {?} platformId
 * @return {?}
 */
export function ɵkeepUnstableUntilFirstFactory(schedulers, platformId) {
    return (/**
     * @template T
     * @param {?} obs$
     * @return {?}
     */
    function keepUnstableUntilFirst(obs$) {
        if (isPlatformServer(platformId)) {
            obs$ = obs$.lift(new ɵBlockUntilFirstOperator(schedulers.ngZone));
        }
        return obs$.pipe(
        // Run the subscribe body outside of Angular (e.g. calling Firebase SDK to add a listener to a change event)
        subscribeOn(schedulers.outsideAngular), 
        // Run operators inside the angular zone (e.g. side effects via tap())
        observeOn(schedulers.insideAngular)
        // INVESTIGATE https://github.com/angular/angularfire/pull/2315
        // share()
        );
    });
}
// DEBUG quick debugger function for inline logging that typescript doesn't complain about
//       wrote it for debugging the ɵlazySDKProxy, commenting out for now; should consider exposing a
//       verbose mode for AngularFire in a future release that uses something like this in multiple places
//       usage: () => log('something') || returnValue
// const log = (...args: any[]): false => { console.log(...args); return false }
// The problem here are things like ngOnDestroy are missing, then triggering the service
// rather than dig too far; I'm capturing these as I go.
/** @type {?} */
const noopFunctions = ['ngOnDestroy'];
// INVESTIGATE should we make the Proxy revokable and do some cleanup?
//             right now it's fairly simple but I'm sure this will grow in complexity
/** @type {?} */
export const ɵlazySDKProxy = (/**
 * @param {?} klass
 * @param {?} observable
 * @param {?} zone
 * @return {?}
 */
(klass, observable, zone) => {
    return new Proxy(klass, {
        get: (/**
         * @param {?} _
         * @param {?} name
         * @return {?}
         */
        (_, name) => zone.runOutsideAngular((/**
         * @return {?}
         */
        () => {
            if (klass[name]) {
                return klass[name];
            }
            if (noopFunctions.includes(name)) {
                return (/**
                 * @return {?}
                 */
                () => { });
            }
            /** @type {?} */
            let promise = observable.toPromise().then((/**
             * @param {?} mod
             * @return {?}
             */
            mod => {
                /** @type {?} */
                const ret = mod && mod[name];
                // TODO move to proper type guards
                if (typeof ret == 'function') {
                    return ret.bind(mod);
                }
                else if (ret && ret.then) {
                    return ret.then((/**
                     * @param {?} res
                     * @return {?}
                     */
                    (res) => zone.run((/**
                     * @return {?}
                     */
                    () => res))));
                }
                else {
                    return zone.run((/**
                     * @return {?}
                     */
                    () => ret));
                }
            }));
            // recurse the proxy
            return new Proxy((/**
             * @return {?}
             */
            () => undefined), {
                get: (/**
                 * @param {?} _
                 * @param {?} name
                 * @return {?}
                 */
                (_, name) => promise[name]),
                // TODO handle callbacks as transparently as I can 
                apply: (/**
                 * @param {?} self
                 * @param {?} _
                 * @param {?} args
                 * @return {?}
                 */
                (self, _, args) => promise.then((/**
                 * @param {?} it
                 * @return {?}
                 */
                it => it && it(...args))))
            });
        })))
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhcmZpcmUyLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFuZ3VsYXIvZmlyZS8iLCJzb3VyY2VzIjpbImFuZ3VsYXJmaXJlMi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQ0EsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDbkQsT0FBTyxFQUE0RCxjQUFjLEVBQXVDLGNBQWMsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNySixPQUFPLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQVMsTUFBTSxnQkFBZ0IsQ0FBQzs7OztBQUVwRSxTQUFTLElBQUksS0FBSyxDQUFDOzs7O0FBS25CLE1BQU0sT0FBTyxjQUFjOzs7OztJQUN6QixZQUFvQixJQUFTLEVBQVUsV0FBZ0IsY0FBYztRQUFqRCxTQUFJLEdBQUosSUFBSSxDQUFLO1FBQVUsYUFBUSxHQUFSLFFBQVEsQ0FBc0I7SUFBSSxDQUFDOzs7O0lBRTFFLEdBQUc7UUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDN0IsQ0FBQzs7Ozs7OztJQUVELFFBQVEsQ0FBQyxJQUF1RCxFQUFFLEtBQWMsRUFBRSxLQUFXOztjQUNyRixVQUFVLEdBQUcsSUFBSSxDQUFDLElBQUk7Ozs7Y0FHdEIsVUFBVTs7Ozs7UUFBRyxVQUFzQyxLQUFVO1lBQ2pFLFVBQVUsQ0FBQyxVQUFVOzs7WUFBQyxHQUFHLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztZQUM1QixDQUFDLEVBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQTtRQUVELHNHQUFzRztRQUN0RyxpR0FBaUc7UUFDakcsK0dBQStHOztRQUYvRyxzR0FBc0c7UUFDdEcsaUdBQWlHO1FBQ2pHLCtHQUErRztRQUMvRyxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUs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RSxDQUFDLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUMsQ0FBQTthQUNoRSxDQUNGLENBQUE7UUFDSCxDQUFDLEVBQUMsQ0FBQTtLQUNILENBQUMsQ0FBQTtBQUNKLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGlvblRva2VuLCBOZ1pvbmUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1TZXJ2ZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgU3Vic2NyaXB0aW9uLCBTY2hlZHVsZXJMaWtlLCBTY2hlZHVsZXJBY3Rpb24sIHF1ZXVlU2NoZWR1bGVyLCBPcGVyYXRvciwgU3Vic2NyaWJlciwgVGVhcmRvd25Mb2dpYywgYXN5bmNTY2hlZHVsZXIgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHN1YnNjcmliZU9uLCBvYnNlcnZlT24sIHRhcCwgc2hhcmUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cblxuLyoqXG4gKiBTY2hlZHVsZXMgdGFza3Mgc28gdGhhdCB0aGV5IGFyZSBpbnZva2VkIGluc2lkZSB0aGUgWm9uZSB0aGF0IGlzIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gKi9cbmV4cG9ydCBjbGFzcyDJtVpvbmVTY2hlZHVsZXIgaW1wbGVtZW50cyBTY2hlZHVsZXJMaWtlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBhbnksIHByaXZhdGUgZGVsZWdhdGU6IGFueSA9IHF1ZXVlU2NoZWR1bGVyKSB7IH1cblxuICBub3coKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVsZWdhdGUubm93KCk7XG4gIH1cblxuICBzY2hlZHVsZSh3b3JrOiAodGhpczogU2NoZWR1bGVyQWN0aW9uPGFueT4sIHN0YXRlPzogYW55KSA9PiB2b2lkLCBkZWxheT86IG51bWJlciwgc3RhdGU/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xuICAgIGNvbnN0IHRhcmdldFpvbmUgPSB0aGlzLnpvbmU7XG4gICAgLy8gV3JhcCB0aGUgc3BlY2lmaWVkIHdvcmsgZnVuY3Rpb24gdG8gbWFrZSBzdXJlIHRoYXQgaWYgbmVzdGVkIHNjaGVkdWxpbmcgdGFrZXMgcGxhY2UgdGhlXG4gICAgLy8gd29yayBpcyBleGVjdXRlZCBpbiB0aGUgY29ycmVjdCB6b25lXG4gICAgY29uc3Qgd29ya0luWm9uZSA9IGZ1bmN0aW9uICh0aGlzOiBTY2hlZHVsZXJBY3Rpb248YW55Piwgc3RhdGU6IGFueSkge1xuICAgICAgdGFyZ2V0Wm9uZS5ydW5HdWFyZGVkKCgpID0+IHtcbiAgICAgICAgd29yay5hcHBseSh0aGlzLCBbc3RhdGVdKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNjaGVkdWxpbmcgaXRzZWxmIG5lZWRzIHRvIGJlIHJ1biBpbiB6b25lIHRvIGVuc3VyZSBzZXRJbnRlcnZhbCBjYWxscyBmb3IgYXN5bmMgc2NoZWR1bGluZyBhcmUgZG9uZVxuICAgIC8vIGluc2lkZSB0aGUgY29ycmVjdCB6b25lLiBUaGlzIHNjaGVkdWxlciBuZWVkcyB0byBzY2hlZHVsZSBhc3luY2hyb25vdXNseSBhbHdheXMgdG8gZW5zdXJlIHRoYXRcbiAgICAvLyBmaXJlYmFzZSBlbWlzc2lvbnMgYXJlIG5ldmVyIHN5bmNocm9ub3VzLiBTcGVjaWZ5aW5nIGEgZGVsYXkgY2F1c2VzIGlzc3VlcyB3aXRoIHRoZSBxdWV1ZVNjaGVkdWxlciBkZWxlZ2F0ZS5cbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zY2hlZHVsZSh3b3JrSW5ab25lLCBkZWxheSwgc3RhdGUpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIMm1QmxvY2tVbnRpbEZpcnN0T3BlcmF0b3I8VD4gaW1wbGVtZW50cyBPcGVyYXRvcjxULCBUPiB7XG4gIHByaXZhdGUgdGFzazogTWFjcm9UYXNrIHwgbnVsbCA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSB6b25lOiBhbnkpIHsgfVxuXG4gIGNhbGwoc3Vic2NyaWJlcjogU3Vic2NyaWJlcjxUPiwgc291cmNlOiBPYnNlcnZhYmxlPFQ+KTogVGVhcmRvd25Mb2dpYyB7XG4gICAgY29uc3QgdW5zY2hlZHVsZVRhc2sgPSB0aGlzLnVuc2NoZWR1bGVUYXNrLmJpbmQodGhpcyk7XG4gICAgdGhpcy50YXNrID0gdGhpcy56b25lLnJ1bigoKSA9PiBab25lLmN1cnJlbnQuc2NoZWR1bGVNYWNyb1Rhc2soJ2ZpcmViYXNlWm9uZUJsb2NrJywgbm9vcCwge30sIG5vb3AsIG5vb3ApKTtcblxuICAgIHJldHVybiBzb3VyY2UucGlwZShcbiAgICAgIHRhcCh1bnNjaGVkdWxlVGFzaywgdW5zY2hlZHVsZVRhc2ssIHVuc2NoZWR1bGVUYXNrKVxuICAgICkuc3Vic2NyaWJlKHN1YnNjcmliZXIpLmFkZCh1bnNjaGVkdWxlVGFzayk7XG4gIH1cblxuICBwcml2YXRlIHVuc2NoZWR1bGVUYXNrKCkge1xuICAgIGlmICh0aGlzLnRhc2sgIT0gbnVsbCAmJiB0aGlzLnRhc2suc3RhdGUgPT09ICdzY2hlZHVsZWQnKSB7XG4gICAgICB0aGlzLnRhc2suaW52b2tlKCk7XG4gICAgICB0aGlzLnRhc2sgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgybVBbmd1bGFyRmlyZVNjaGVkdWxlcnMge1xuICBwdWJsaWMgcmVhZG9ubHkgb3V0c2lkZUFuZ3VsYXI6IMm1Wm9uZVNjaGVkdWxlcjtcbiAgcHVibGljIHJlYWRvbmx5IGluc2lkZUFuZ3VsYXI6IMm1Wm9uZVNjaGVkdWxlcjtcblxuICBjb25zdHJ1Y3RvcihwdWJsaWMgbmdab25lOiBOZ1pvbmUpIHtcbiAgICB0aGlzLm91dHNpZGVBbmd1bGFyID0gbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IG5ldyDJtVpvbmVTY2hlZHVsZXIoWm9uZS5jdXJyZW50KSk7XG4gICAgdGhpcy5pbnNpZGVBbmd1bGFyID0gbmdab25lLnJ1bigoKSA9PiBuZXcgybVab25lU2NoZWR1bGVyKFpvbmUuY3VycmVudCwgYXN5bmNTY2hlZHVsZXIpKTtcbiAgfVxufVxuXG4vKipcbiAqIE9wZXJhdG9yIHRvIGJsb2NrIHRoZSB6b25lIHVudGlsIHRoZSBmaXJzdCB2YWx1ZSBoYXMgYmVlbiBlbWl0dGVkIG9yIHRoZSBvYnNlcnZhYmxlXG4gKiBoYXMgY29tcGxldGVkL2Vycm9yZWQuIFRoaXMgaXMgdXNlZCB0byBtYWtlIHN1cmUgdGhhdCB1bml2ZXJzYWwgd2FpdHMgdW50aWwgdGhlIGZpcnN0XG4gKiB2YWx1ZSBmcm9tIGZpcmViYXNlIGJ1dCBkb2Vzbid0IGJsb2NrIHRoZSB6b25lIGZvcmV2ZXIgc2luY2UgdGhlIGZpcmViYXNlIHN1YnNjcmlwdGlvblxuICogaXMgc3RpbGwgYWxpdmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiDJtWtlZXBVbnN0YWJsZVVudGlsRmlyc3RGYWN0b3J5KFxuICBzY2hlZHVsZXJzOiDJtUFuZ3VsYXJGaXJlU2NoZWR1bGVycyxcbiAgcGxhdGZvcm1JZDogT2JqZWN0XG4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGtlZXBVbnN0YWJsZVVudGlsRmlyc3Q8VD4ob2JzJDogT2JzZXJ2YWJsZTxUPik6IE9ic2VydmFibGU8VD4ge1xuICAgIGlmIChpc1BsYXRmb3JtU2VydmVyKHBsYXRmb3JtSWQpKSB7XG4gICAgICBvYnMkID0gb2JzJC5saWZ0KFxuICAgICAgICBuZXcgybVCbG9ja1VudGlsRmlyc3RPcGVyYXRvcihzY2hlZHVsZXJzLm5nWm9uZSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9icyQucGlwZShcbiAgICAgIC8vIFJ1biB0aGUgc3Vic2NyaWJlIGJvZHkgb3V0c2lkZSBvZiBBbmd1bGFyIChlLmcuIGNhbGxpbmcgRmlyZWJhc2UgU0RLIHRvIGFkZCBhIGxpc3RlbmVyIHRvIGEgY2hhbmdlIGV2ZW50KVxuICAgICAgc3Vic2NyaWJlT24oc2NoZWR1bGVycy5vdXRzaWRlQW5ndWxhciksXG4gICAgICAvLyBSdW4gb3BlcmF0b3JzIGluc2lkZSB0aGUgYW5ndWxhciB6b25lIChlLmcuIHNpZGUgZWZmZWN0cyB2aWEgdGFwKCkpXG4gICAgICBvYnNlcnZlT24oc2NoZWR1bGVycy5pbnNpZGVBbmd1bGFyKVxuICAgICAgLy8gSU5WRVNUSUdBVEUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhcmZpcmUvcHVsbC8yMzE1XG4gICAgICAvLyBzaGFyZSgpXG4gICAgKTtcbiAgfVxufVxuXG50eXBlIEZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gZXh0ZW5kcyBGdW5jdGlvbiA/IEsgOiBuZXZlciB9W2tleW9mIFRdO1xudHlwZSBQcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+ID0geyBbSyBpbiBGdW5jdGlvblByb3BlcnR5TmFtZXM8VD5dOiBSZXR1cm5UeXBlPFRbS10+IGV4dGVuZHMgUHJvbWlzZTxhbnk+ID8gSyA6IG5ldmVyIH1bRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTtcbnR5cGUgTm9uUHJvbWlzZVJldHVybmluZ0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHsgW0sgaW4gRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogUmV0dXJuVHlwZTxUW0tdPiBleHRlbmRzIFByb21pc2U8YW55PiA/IG5ldmVyIDogSyB9W0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPl07XG50eXBlIE5vbkZ1bmN0aW9uUHJvcGVydHlOYW1lczxUPiA9IHsgW0sgaW4ga2V5b2YgVF06IFRbS10gZXh0ZW5kcyBGdW5jdGlvbiA/IG5ldmVyIDogSyB9W2tleW9mIFRdO1xuXG5leHBvcnQgdHlwZSDJtVByb21pc2VQcm94eTxUPiA9IHsgW0sgaW4gTm9uRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogUHJvbWlzZTxUW0tdPiB9ICZcbiAgeyBbSyBpbiBOb25Qcm9taXNlUmV0dXJuaW5nRnVuY3Rpb25Qcm9wZXJ0eU5hbWVzPFQ+XTogKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VFtLXT4pID0+IFByb21pc2U8UmV0dXJuVHlwZTxUW0tdPj4gfSAmXG4gIHsgW0sgaW4gUHJvbWlzZVJldHVybmluZ0Z1bmN0aW9uUHJvcGVydHlOYW1lczxUPiAgIF06ICguLi5hcmdzOiBQYXJhbWV0ZXJzPFRbS10+KSA9PiBSZXR1cm5UeXBlPFRbS10+IH07XG5cblxuLy8gREVCVUcgcXVpY2sgZGVidWdnZXIgZnVuY3Rpb24gZm9yIGlubGluZSBsb2dnaW5nIHRoYXQgdHlwZXNjcmlwdCBkb2Vzbid0IGNvbXBsYWluIGFib3V0XG4vLyAgICAgICB3cm90ZSBpdCBmb3IgZGVidWdnaW5nIHRoZSDJtWxhenlTREtQcm94eSwgY29tbWVudGluZyBvdXQgZm9yIG5vdzsgc2hvdWxkIGNvbnNpZGVyIGV4cG9zaW5nIGFcbi8vICAgICAgIHZlcmJvc2UgbW9kZSBmb3IgQW5ndWxhckZpcmUgaW4gYSBmdXR1cmUgcmVsZWFzZSB0aGF0IHVzZXMgc29tZXRoaW5nIGxpa2UgdGhpcyBpbiBtdWx0aXBsZSBwbGFjZXNcbi8vICAgICAgIHVzYWdlOiAoKSA9PiBsb2coJ3NvbWV0aGluZycpIHx8IHJldHVyblZhbHVlXG4vLyBjb25zdCBsb2cgPSAoLi4uYXJnczogYW55W10pOiBmYWxzZSA9PiB7IGNvbnNvbGUubG9nKC4uLmFyZ3MpOyByZXR1cm4gZmFsc2UgfVxuXG4vLyBUaGUgcHJvYmxlbSBoZXJlIGFyZSB0aGluZ3MgbGlrZSBuZ09uRGVzdHJveSBhcmUgbWlzc2luZywgdGhlbiB0cmlnZ2VyaW5nIHRoZSBzZXJ2aWNlXG4vLyByYXRoZXIgdGhhbiBkaWcgdG9vIGZhcjsgSSdtIGNhcHR1cmluZyB0aGVzZSBhcyBJIGdvLlxuY29uc3Qgbm9vcEZ1bmN0aW9ucyA9IFsnbmdPbkRlc3Ryb3knXTtcblxuLy8gSU5WRVNUSUdBVEUgc2hvdWxkIHdlIG1ha2UgdGhlIFByb3h5IHJldm9rYWJsZSBhbmQgZG8gc29tZSBjbGVhbnVwP1xuLy8gICAgICAgICAgICAgcmlnaHQgbm93IGl0J3MgZmFpcmx5IHNpbXBsZSBidXQgSSdtIHN1cmUgdGhpcyB3aWxsIGdyb3cgaW4gY29tcGxleGl0eVxuZXhwb3J0IGNvbnN0IMm1bGF6eVNES1Byb3h5ID0gKGtsYXNzOiBhbnksIG9ic2VydmFibGU6IE9ic2VydmFibGU8YW55Piwgem9uZTogTmdab25lKSA9PiB7XG4gIHJldHVybiBuZXcgUHJveHkoa2xhc3MsIHtcbiAgICBnZXQ6IChfLCBuYW1lOnN0cmluZykgPT4gem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICBpZiAoa2xhc3NbbmFtZV0pIHsgcmV0dXJuIGtsYXNzW25hbWVdIH1cbiAgICAgIGlmIChub29wRnVuY3Rpb25zLmluY2x1ZGVzKG5hbWUpKSB7IHJldHVybiAoKSA9PiB7fSB9XG4gICAgICBsZXQgcHJvbWlzZSA9IG9ic2VydmFibGUudG9Qcm9taXNlKCkudGhlbihtb2QgPT4ge1xuICAgICAgICBjb25zdCByZXQgPSBtb2QgJiYgbW9kW25hbWVdO1xuICAgICAgICAvLyBUT0RPIG1vdmUgdG8gcHJvcGVyIHR5cGUgZ3VhcmRzXG4gICAgICAgIGlmICh0eXBlb2YgcmV0ID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gcmV0LmJpbmQobW9kKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXQgJiYgcmV0LnRoZW4pIHtcbiAgICAgICAgICByZXR1cm4gcmV0LnRoZW4oKHJlczphbnkpID0+IHpvbmUucnVuKCgpID0+IHJlcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB6b25lLnJ1bigoKSA9PiByZXQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIHJlY3Vyc2UgdGhlIHByb3h5XG4gICAgICByZXR1cm4gbmV3IFByb3h5KCgpID0+IHVuZGVmaW5lZCwge1xuICAgICAgICAgIGdldDogKF8sIG5hbWUpID0+IHByb21pc2VbbmFtZV0sXG4gICAgICAgICAgLy8gVE9ETyBoYW5kbGUgY2FsbGJhY2tzIGFzIHRyYW5zcGFyZW50bHkgYXMgSSBjYW4gXG4gICAgICAgICAgYXBwbHk6IChzZWxmLCBfLCBhcmdzKSA9PiBwcm9taXNlLnRoZW4oaXQgPT4gaXQgJiYgaXQoLi4uYXJncykpXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9KVxuICB9KVxufTsiXX0=